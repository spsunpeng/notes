# 一、数据结构

数组

链表

- 单向链表：表头指针，每个node节点包括数据和下一个节点的地址
- 双向链表：表头指针，表尾指针，每个node节点都包括数据、下一个节点的地址和上一个节点的地址

散列表（哈希表）

- 原理：地址和哈希值维护一个映射表，便于增删改查。哈希值一般是key的哈希，但没有key的时候，value自身也可以哈希。因为哈希碰撞的原因，增删改查的效率都是 O(1)<O(hash)<O(n).
- 新建：新建一个数组，数组长度固定。
- 插入：哈希值取余数组长度，将数据插入到对应的序号中。如果取余结果重复（哈希碰撞），解决方法：链式地址法和线性探测法。

- 查询：通过hash值直接找到地址，进而取值（key-value形式有意义，单value形式用作判定是否存在）。因为哈希碰撞原因，可能会得到多个，需要遍历这几个。
- 删除：也是通过hash值直接找到地址。
- 遍历：单value哈希表的主要使用方式。

树

- 原理
- 插入
- 删除
- 查询
- 遍历



栈：后进先出，栈是限定仅在表尾（栈顶，表头称作栈底）进行插入和删除操作的线性表。实现方式：如单项链表，数组

- 数组实现：一个只能增删表尾的限制数组
- 链表实现：一个反着的链表（表尾指针，数据，上一个节点的地址）

队列：先进后出，在一端添加元素（入队），在另一端取出元素（出队）。实现方式，如双向链表

- 数组实现
  - 开辟一个定容的数组，并定义头、尾两个指针。
  - 增：向前移动一格头部指针，当到达终点后循环移动，当尾指针追上头指针时，队列已满，需要扩容。
  - 删：向前移动一格尾部指针，当到达终点后循环移动，当头指针追上尾指针时，队列为空

- 链表实现：双向链表





# 二、java

底层实现仍然是使用数组，链表，哈希表，红黑树，但是暴漏给使用者是按功能划分：set，list，map

## 1、基础

- *Collection*    

  - set 

    - HashSet 无序的，不可重复的。底层：HashMap的封装（key和value是同一个），HashMap<E,Object> map

    - LinkHashSet  有序的，不可重复的。底层：哈希+双向链表，按照哈希的方式存储，每个节点额外存储before和after属性。遍历时不按照数组的顺序遍历，而是根据before和after属性寻找下一个节点，所以变得有序。

    - TreeSet 

  - *list*

    - ArrayList 读快改慢

    - LinkedList 双向链表
    - *Vector*
      - Stack：栈

  - *Queue*
    - Deque
      - LinkedList  双向链表

- *Map*

  - HashMap 无序的(不是插入顺序)、不可重复的(key不能重复)。实现方式：key-value的Set集合，Set<Map.Entry<K,V>> entrySet
    - LinkHashMap  有序的，不可重复的
  - TreeMap：底层红黑树，按照大小排序，所以在需要排序的情况下使用。





## 2、增删查改

| 操作 | set                                      | list                                             | Map                                                          | Stack(Stack是实现类) | Queue(Queue是接口，实现类是LinkedList)                       |
| ---- | ---------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ | -------------------- | ------------------------------------------------------------ |
| 增   | boolean add(E e)                         | boolean  add(E e)  void  add(int index, E e)     | Object  put(Object key, Object value)  如果key已存在，则返回被替换掉的元素  void  putAll(Map t); | E  push(E item);     | boolean  add(E e);  **boolean offer(E e);**队列为空返回null  在队头插入 |
| 删   | boolean  remove(Object o)  void  clear() | boolean  remove(Object o)  void  clear()         | Object  remove(Object key);  void  clear()                   | E  pop();            | E remove();   **E poll();** 队列为空返回null  获取并删除队头 |
| 查   | boolean  contains(Object o)              | E  get(int index)  boolean  contains(Object o)   | Object  get(Object key);  boolean  containsKey(Object key);  boolean  containsValue(Object value); | E  peek();           | E  element();  **E peek()**; 队列为空返回null  获取但不移除队头 |
| 改   |                                          | E  set(int index, E element)  返回被替换掉的元素 | Object  put(Object key, Object value)  如果key已存在，则返回被替换掉的元素 |                      |                                                              |
| 判空 | boolean  isEmpty()                       | boolean  isEmpty()                               | boolean  isEmpty()                                           | boolean  empty()     | boolean  isEmpty()                                           |
| 大小 | int  size();                             | int  size();                                     | int  size();                                                 |                      |                                                              |
| 遍历 | 一样                                     | 一样                                             | 一样                                                         | 一样                 | 一样                                                         |



## 3、遍历Iterator

```java
public void fun1(Collection c) {
    Iterator i = c.iterator();       //1、定义迭代器，初始位置为-1
    while (i.hasNext()){          //2.（p+1） == null 判断有没有下一个
    if(i.next().equals("aaa")){   //3.p++并返回*p，先++指向下一个，然后在解引用
        i.remove();             //4.删除
      }
    }                          //总结：核心原因是初始为-1，如此循环的思想就是需要的时候再给
}
```

- 当程序中有两个i.next()时,会有两次++，程序每一循环都是+2，后一个就和前一个不一样，后一个也需要先判断是否越界，i.hasNext()，所以只是为了*p的使用，那么先要给出Object o = i.next(); 然后就可以反复使用o，而不用担心多次++



## 4、常用算法Collections  

Collections中的算法只对List实现，因为List是有序的数据结构，且都是静态方法。





## 5、map

HashMap(String, String)

HashMap(Integer, String)

HashMap(Node, String)

TreeMap()

注意头尾指向的修改，防止内存泄漏





# 四、算法和数据结构新手班课程详情

## 负责老师

左程云

## 算法系列课程视频总链接

https://www.mashibing.com/subject/21

## 所有代码

https://github.com/algorithmzuo/algorithm-primary

## 课程介绍

算法和数据结构新手班的唯一意义就是让你能够听懂算法后续的课程。

新手班是一个学前准备，带学员见识一下常见的数据结构、算法以及coding细节。

很多同学没有算法基础，后面的课程听起来吃力，就需要一个解释非常全面的学前阶段，

新手班就是为这样的同学准备的。

如果听起来简单，可以跳过新手班，直接进入体系学习班进行学习。

## 针对人群

刚开始接触算法的IT从业者

刚开始接触算法的大学生

## 课程宗旨

网络上对于互联网名企算法面试的视频有不少，但是大部分课程启发程度有限，讲解也不够直白、易懂。课程致力于面向所有算法学习新手学员，用8节课(16小时)和浅显易懂的算法题目，帮助学员进入到算法学习，做到先熟悉、再深入。

课程设计和学习效果是一致的，解决学习痛苦问题，解决工作痛苦问题，解决时间成本问题，生活那么忙，**总要抽出一点时间学习提升自己**，那么我们就攥起拳头直打痛点，每天稳健成长一小步。

## 课程特点

1，只涉及简单的算法和数据结构

2，讲述直白，听懂门槛不高

3，大部分内容在后续课程都有进一步的推演、变化、深入

4，设计的题目都是面试常考题

5，逐行讲解code

## 算法和数据结构新手班ppt文字版合集

```
算法和数据结构新手班课程内容（1~8节）

01 位运算、算法是什么、介绍位运算和简单排序
内容：
讲解二进制、位运算
介绍什么是算法
讲解冒泡、选择、插入排序
题目：
实现打印一个整数的二进制
给定一个参数N，返回1!+2!+3!+4!+…+N!的结果
实现冒泡排序
实现选择排序
实现插入排序


02 数据结构的大分类、介绍前缀和与对数器
内容：
什么是数据结构、组成各种数据结构最基本的元件
前缀和数组
随机函数
对数器的使用
题目：
实现前缀和数组
如何用1~5的随机函数加工出1~7的随机函数
如何用a~b的随机函数加工出c~d的随机函数
展示对数器的使用
如何把不等概率随机函数变成等概率随机函数


03 介绍二分法，介绍时间复杂度、动态数组、哈希表和有序表
内容：
二分法
使用二分法解决不同的题目
时间复杂度
动态数组
按值传递、按引用传递
哈希表
有序表
题目：
有序数组中找到num
有序数组中找到>=num最左的位置
有序数组中找到<=num最右的位置
局部最小值问题
哈希表使用的code讲解
有序表使用的code讲解


04 链表相关的简单面试题
内容：
单双链表的定义
栈、队列
双端队列
题目：
反转单链表
反转双链表
用单链表实现队列
用单链表实现栈
用双链表实现双端队列
K个节点的组内逆序调整问题：
给定一个单链表的头节点head，和一个正数k
实现k个节点的小组内部逆序，如果最后一组不够k个就不调整
例子: 
调整前：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8，k = 3
调整后：3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8
两个链表相加问题
给定两个链表的头节点head1和head2，
认为从左到右是某个数字从低位到高位，返回相加之后的链表
例子     4 -> 3 -> 6        2 -> 5 -> 3
返回     6 -> 8 -> 9
解释     634 + 352 = 986
两个有序链表的合并
给定两个有序链表的头节点head1和head2，
返回合并之后的大链表，要求依然有序
例子     1 -> 3 -> 3 -> 5 -> 7   2 -> 2 -> 3 -> 3-> 7
返回     1 -> 2 -> 2 -> 3 -> 3 -> 3 -> 3 -> 5 -> 7


05 位图、位运算实现加减乘除
内容：
位图
位运算使用的进一步学习：实现加减乘除
题目：
现场写位图的code、讲解
位运算的加减乘除


06 比较器、优先级队列、二叉树
内容：
比较器
优先级队列
二叉树的基本遍历
二叉树的递归套路
题目：
补充了一个链表的题目
合并多个有序链表
Leetcode原题，https://leetcode.com/problems/merge-k-sorted-lists
判断两颗树是否结构相同
Leetcode原题，https://leetcode.com/problems/same-tree
判断一棵树是否是镜面树
Leetcode原题，https://leetcode.com/problems/symmetric-tree
返回一棵树的最大深度
Leetcode原题，https://leetcode.com/problems/maximum-depth-of-binary-tree
用先序数组和中序数组重建一棵树
Leetcode原题，https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal
用code展示比较器的使用
二叉树先序、中序、后序遍历的代码实现、介绍递归序


07 继续二叉树的很多题目
内容：
进一步讲解二叉树题目，来熟悉二叉树
题目：
二叉树按层遍历并收集节点
Leetcode原题，https://leetcode.com/problems/binary-tree-level-order-traversal-ii
判断是否是平衡搜索二叉树
Leetcode原题，https://leetcode.com/problems/balanced-binary-tree
在二叉树上能否组成路径和
Leetcode原题，https://leetcode.com/problems/path-sum
在二叉树上收集所有达标的路径和
Leetcode原题，https://leetcode.com/problems/path-sum-ii



08 介绍归并排序和快速排序
内容：
讲解一个位运算的题目
归并排序
快速排序
题目：
不要用任何比较判断，返回两个数中较大的数
归并排序的递归实现和非递归实现
快速排序的递归实现和非递归实现
```







//左==空 右==空，右==1， 右>1

//有





# 五、算法体系学习

## 1、开班

笔记：https://shimo.im/docs/68cd6h3TwygPwx8W/read



## 2、复杂度 & 基础排序 & 二分法

### 2.1 算法复杂度

1) 时间复杂度（流程决定）

2) 额外空间复杂度（流程决定）

常数项时间（实现细节决定），一般不通过数学的方式计较，而通过实际测试比较。

#### 2.2.1 常数操作

常见的算术运算（+、-、*、/、% 等）
常见的位运算（>>、>>>、<<、|、&、^等）
赋值、比较、自增、自减操作等
数组寻址操作

总之，执行时间固定的操作都是常数时间的操作。
反之，执行时间不固定的操作，都不是常数时间的操作

#### 2.2.3 时间复杂度

排名从好到差：
O(1)   
O(logN)   
O(N)   
O(N*logN)   
O(N^2)   O(N^3)   …   O(N^K)
O(2^N)   O(3^N)   …   O(K^N)
O(N!)



### 2.2 基础排序

选择排序：比较所有的数，找到最小的数，排在第一位。重复此步。

冒泡排序：从起始位置，比较相邻的的数，前数 > 后数，则交换位置，一次循环则最大的数冒到最后。重复此步。

插入排序：前n相有序，不断把n+1位置的数插入到前面的有序列表中。知道所有数都插入进去。



### 2.3 二分法

1) 在一个有序数组中，找某个数是否存在 

二分查找。

2) 在一个有序数组中，找>=某个数最左侧的位置 

（二分查找 + 二分到底） + （记录最左侧的位置 + 每次二分都跟新位置）

3) 在一个有序数组中，找<=某个数最右侧的位置 

（二分查找 + 二分到底） + （记录最左侧的位置 + 每次二分都跟新位置）

4) 局部最小值问题 

只有有个拐点，它就是整个数据的局部最小值之一，不需要求最小的那个值。





## 3、二进制

### 3.1 计算机基础

#### 3.1.1 字节 & 编码

bit： [bɪt] ，位，比特位

byte：[baɪt]，b，字节，1byte = 8bit

kb：1kb = 1000b

字符：根据编码格式不同所占存储大小不同

ASCII码：一个字符占一个字节的空间。换算为十进制 ，最小值-128，最大值127。如一个ASCII码就是一个字节。

Unicode编码：一个英文字符（大小写英文字母和标点）等于两个字节，一个中文（简体，繁体，标点）等于两个字节。

UTF-8编码：一个英文字符（大小写英文字母和标点）等于一个字节，一个中文（简体，繁体，标点）等于三个字节。

类型

short：2个字节，范围 2^16 --->  -32768～32767 

int：4个字节，4×8=32位，表示范围 2^32 

long：8个字节，范围 2^64



#### 3.1.2 小/大端存储

| 16进制                   | 0X01          | 0X02      | 0X03      | 0X04      |
| ------------------------ | ------------- | --------- | --------- | --------- |
| 小端 16进制 short s = 1  | **01**        | 00        | 00        | 00        |
| 大端 16进制 short s = 1  | 00            | 00        | 00        | 01        |
|                          |               |           |           |           |
| 小端 16进制 short s = -1 | 01            | 00        | 00        | 80        |
| 大端 16进制 short s = -1 | 80            | 00        | 00        | 01        |
| 大端 2进制 short s = -1  | **1000 0000** | 0000 0000 | 0000 0000 | 0000 0001 |

java中使用的是大端存储，操作系统一般用的是小端存储，C/C++的存储与编译平台所在的CPU相关。



**小端存储** :便于数据之间的类型转换，例如:long类型转换为int类型时，高地址部分的数据可以直接截掉。起码正数是这样的，负数总不能把符号位截取了吧？

**大端存储** :便于数据类型的符号判断，因为最低地址位数据即为符号位，可以直接判断数据的正负号。



32位电脑表示内存寻址是32位，寄存器是32位，cpu是32位，操作系统是32位。32位 = 4字节，地址范围是 0 ~ 2^32  = 4G，所以32位操作系统的内存最大为4G。

64位操作系统同理，64位，地址范围 0 ~ 2^64 = 64G，所以64位操作系统最大内存位 64G？



### 3.2 反码 & 补码

- 一个数在计算机中的二进制表示形式， 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号， 正数为0， 负数为1。
- 而让计算机辨别”符号位”会让计算机的基础电路设计变得十分复杂，于是就让符号位也参与运算，从而产生了补码。
- **数值在计算机中是以补码的方式存储的。**

- 正数的补码是本身，负数的补码是反码加一。
- 但是“反码加一”只是补码所具有的一个性质，不能被定义成补码。负数的补码，是能够和其相反数相加通过溢出从而使计算机内计算结果变为0的二进制码。
- **补码定义：为了让基础电路不用区分符号位，同时满足：正数+负数=0 的性质，设计出了补码。**
- 补码性质：补码的补码是源码
- 1000 0000 不是-0，所以负数比正数多一个



 

### 3.2 位运算符

- 数值在计算机中是以补码的方式存储的，位运算也是用补码计算的，不用区分符号位。

| 位运算符 | 中文     | 功能       | 用法一                            | 用法二         |
| -------- | -------- | ---------- | --------------------------------- | -------------- |
| <<       | 左移     | 乘以2      | 31 << 1 = 31×2 = 64               | 1 << 31 = 2^32 |
| >>       | 右移     | 除以2      |                                   |                |
| &        | 按位与   |            |                                   |                |
| \|       | 按位或   |            |                                   |                |
| ~        | 按位取反 |            |                                   |                |
| ^        | 异或     | 无进位相加 | N^0=N  N^N=0  N^1111=~N   N^N^N=N | 分配律  交换律 |
| ~(a^b)   | 同或     |            | Java没有同或问算符                |                |

#### 3.2.1 按位取反~

- 数值在计算机中是以补码的方式存储的，位运算也是用补码计算的，不用区分符号位。例如：

~12 = -13

```
12
原码：0000 1100
反码：0000 1100
补码：0000 1100
补码按位取反：
~(0000 1100)=1111 0011(按位取反后的补码为负数，反向求反码、原码) 
反码：1111 0010
原码：1000 1101  (十进制：-13)
即 ~12=-13
```

~-12 = 11

```
-12
原码：1000 1100
反码：1111 0011
补码：1111 0100

补码按位取反：
~(1111 0100)=0000 1011 （按位取反后的补码为正数，其反码、原码相同）
反码：0000 1011
原码：0000 1011  (十进制：11)
即 ~- 12=11
```





### 3.3 原题

1）如何不用额外变量交换两个数。

解：a=a+b; b=a-b; a=a-b; 先给其中一个数赋值俩个数的 和/差/积/商，然后。。。 本题用无进位相加^

2）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数。 

解：利用^的性质： N^0=N  N^N=0，得出出现次数是奇数的那个数。

3）怎么把一个int类型的数，提取出最右侧的1来。

解：N&(-N) = 最右侧1

4）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

解：设这两个数是A和B，通过题2得出A^B，通过题3得出A和B得出两个数之间的差异。根据差异分组，再次异或，分别得出A和B

5）一个数组中有一种数出现K次，其他数都出现了M次，M > 1,  K < M，找到出现了K次的数。要求，额外空间复杂度O(1)，时间复杂度O(N)。

解：定义int[32]，把数组中的数都按位放大其中，不能被M整除的数就是答案。



## 4、链表 & 递归 & 哈希表

### 4.1 链表

单链表和双链表如何反转

把链表中的给定值都删除

双向链表实现栈和队列

数组实现栈和队列

155.[实现最小栈](https://leetcode-cn.com/problems/min-stack)

解：用链表的结构实现栈，增加一个min节点。

如何用栈结构实现队列结构

如何用队列结构实现栈结构

用递归方法求数组中的最大值



### 4.2 递归

- 递归图

  ​                 f(0,10)

  ​      f(0,5)            f(6,10)

  f(0,3)  f(4,5)    f(6,8)  f(9,10)  

- 递归就是打化小的过程
- 所有的递归都可以改成循环

- master公式：T(N) = a(N/b) + N^d

  log a b < d :  O(N) = O(N^d)

  log a b > d :  O(N) = O(N^(log a b))

  log a b = d :  O(N) = O(N*(log a b))



### 4.3 哈希表 & 有序表

哈希表：HashMap

- 时间复杂度：增删改查都是O(1)

- 相同的key直接覆盖
- 判断是否相等：基本类型判断方式是==
- 判断是否相等：包装类型/string判断方式是equal，比较的是值。
- 判断是否相等：Object判断方式也是equal，但对于没有重写equal方法的类，比较的就是hashcode。



有序表：在java中有序表是接口，实现方式包括红黑树，sb树，平衡二叉树等等，java中的treeMap实现方式是红黑树。













































