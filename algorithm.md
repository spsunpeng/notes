# 一、数据结构

数组

链表

- 单向链表：表头指针，每个node节点包括数据和下一个节点的地址
- 双向链表：表头指针，表尾指针，每个node节点都包括数据、下一个节点的地址和上一个节点的地址

散列表（哈希表）

- 原理：地址和哈希值维护一个映射表，便于增删改查。哈希值一般是key的哈希，但没有key的时候，value自身也可以哈希。因为哈希碰撞的原因，增删改查的效率都是 O(1)<O(hash)<O(n).
- 新建：新建一个数组，数组长度固定。
- 插入：哈希值取余数组长度，将数据插入到对应的序号中。如果取余结果重复（哈希碰撞），解决方法：链式地址法和线性探测法。

- 查询：通过hash值直接找到地址，进而取值（key-value形式有意义，单value形式用作判定是否存在）。因为哈希碰撞原因，可能会得到多个，需要遍历这几个。
- 删除：也是通过hash值直接找到地址。
- 遍历：单value哈希表的主要使用方式。

树

- 原理
- 插入
- 删除
- 查询
- 遍历



栈：后进先出，栈是限定仅在表尾（栈顶，表头称作栈底）进行插入和删除操作的线性表。实现方式：如单项链表，数组

- 数组实现：一个只能增删表尾的限制数组
- 链表实现：一个反着的链表（表尾指针，数据，上一个节点的地址）

队列：先进后出，在一端添加元素（入队），在另一端取出元素（出队）。实现方式，如双向链表

- 数组实现
  - 开辟一个定容的数组，并定义头、尾两个指针。
  - 增：向前移动一格头部指针，当到达终点后循环移动，当尾指针追上头指针时，队列已满，需要扩容。
  - 删：向前移动一格尾部指针，当到达终点后循环移动，当头指针追上尾指针时，队列为空

- 链表实现：双向链表





# 二、java

底层实现仍然是使用数组，链表，哈希表，红黑树，但是暴漏给使用者是按功能划分：set，list，map

## 1、基础

- *Collection*    

  - set 

    - HashSet 无序的，不可重复的。底层：HashMap的封装（key和value是同一个），HashMap<E,Object> map

    - LinkHashSet  有序的，不可重复的。底层：哈希+双向链表，按照哈希的方式存储，每个节点额外存储before和after属性。遍历时不按照数组的顺序遍历，而是根据before和after属性寻找下一个节点，所以变得有序。

    - TreeSet 

  - *list*

    - ArrayList 读快改慢

    - LinkedList 双向链表
    - *Vector*
      - Stack：栈

  - *Queue*
    - Deque
      - LinkedList  双向链表

- *Map*

  - HashMap 无序的(不是插入顺序)、不可重复的(key不能重复)。实现方式：key-value的Set集合，Set<Map.Entry<K,V>> entrySet
    - LinkHashMap  有序的，不可重复的
  - TreeMap：底层红黑树，按照大小排序，所以在需要排序的情况下使用。





## 2、增删查改

| 操作 | set                                      | list                                             | Map                                                          | Stack(Stack是实现类) | Queue(Queue是接口，实现类是LinkedList)                       |
| ---- | ---------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ | -------------------- | ------------------------------------------------------------ |
| 增   | boolean add(E e)                         | boolean  add(E e)  void  add(int index, E e)     | Object  put(Object key, Object value)  如果key已存在，则返回被替换掉的元素  void  putAll(Map t); | E  push(E item);     | boolean  add(E e);  **boolean offer(E e);**队列为空返回null  在队头插入 |
| 删   | boolean  remove(Object o)  void  clear() | boolean  remove(Object o)  void  clear()         | Object  remove(Object key);  void  clear()                   | E  pop();            | E remove();   **E poll();** 队列为空返回null  获取并删除队头 |
| 查   | boolean  contains(Object o)              | E  get(int index)  boolean  contains(Object o)   | Object  get(Object key);  boolean  containsKey(Object key);  boolean  containsValue(Object value); | E  peek();           | E  element();  **E peek()**; 队列为空返回null  获取但不移除队头 |
| 改   |                                          | E  set(int index, E element)  返回被替换掉的元素 | Object  put(Object key, Object value)  如果key已存在，则返回被替换掉的元素 |                      |                                                              |
| 判空 | boolean  isEmpty()                       | boolean  isEmpty()                               | boolean  isEmpty()                                           | boolean  empty()     | boolean  isEmpty()                                           |
| 大小 | int  size();                             | int  size();                                     | int  size();                                                 |                      |                                                              |
| 遍历 | 一样                                     | 一样                                             | 一样                                                         | 一样                 | 一样                                                         |



## 3、遍历Iterator

```java
public void fun1(Collection c) {
    Iterator i = c.iterator();       //1、定义迭代器，初始位置为-1
    while (i.hasNext()){          //2.（p+1） == null 判断有没有下一个
    if(i.next().equals("aaa")){   //3.p++并返回*p，先++指向下一个，然后在解引用
        i.remove();             //4.删除
      }
    }                          //总结：核心原因是初始为-1，如此循环的思想就是需要的时候再给
}
```

- 当程序中有两个i.next()时,会有两次++，程序每一循环都是+2，后一个就和前一个不一样，后一个也需要先判断是否越界，i.hasNext()，所以只是为了*p的使用，那么先要给出Object o = i.next(); 然后就可以反复使用o，而不用担心多次++



## 4、常用算法Collections  

Collections中的算法只对List实现，因为List是有序的数据结构，且都是静态方法。









# 三、算法

1、位运算

左移： <<

31 << 1 = 31×2 = 64      31左移一位

1 << 31 = 2^32                1左移32位



正负数

1000 0000 不是-0，所以负数比正数多一个

0000 0000

计算机存储的都是补码，补码才能代表二级制



#### 二进制

bit： [bɪt] ，位，比特位

byte：[baɪt]，b，字节，1byte = 8bit

kb：1kb = 1000b

字符：根据编码格式不同所占存储大小不同

ASCII码：一个字符占一个字节的空间。换算为十进制 ，最小值-128，最大值127。如一个ASCII码就是一个字节。

Unicode编码：一个英文字符（大小写英文字母和标点）等于两个字节，一个中文（简体，繁体，标点）等于两个字节。

UTF-8编码：一个英文字符（大小写英文字母和标点）等于一个字节，一个中文（简体，繁体，标点）等于三个字节。

类型

short：2个字节，范围 2^16 --->  -32768～32767 

int：4个字节，4×8=32位，表示范围 2^32 

long：8个字节，范围 2^64



正负数

- 正数：首位是0
- 负数：首位是1



补码

- 正数的补码是本身，负数的补码是反码加一。

- 但是“反码加一”只是补码所具有的一个性质，不能被定义成补码。负数的补码，是能够和其相反数相加通过溢出从而使计算机内计算结果变为0的二进制码。
- 所以补码是为了解决：二级制 正数+负数=0
- 补码的补码是源码



异或^

- 相同取0，不同取1

- 与0000异或不变：0101 ^ 0000 = 0101
- 与1111异或等于取反：0101 ^ 1111 = 1010
- 异或的异或等于原数：0101 ^ 1100 = 1001,  1001 ^ 1100 = 0101





| 16进制                   | 0X01          | 0X02      | 0X03      | 0X04      |
| ------------------------ | ------------- | --------- | --------- | --------- |
| 小端 16进制 short s = 1  | **01**        | 00        | 00        | 00        |
| 大端 16进制 short s = 1  | 00            | 00        | 00        | 01        |
|                          |               |           |           |           |
| 小端 16进制 short s = -1 | 01            | 00        | 00        | 80        |
| 大端 16进制 short s = -1 | 80            | 00        | 00        | 01        |
| 大端 2进制 short s = -1  | **1000 0000** | 0000 0000 | 0000 0000 | 0000 0001 |



java中使用的是大端存储，操作系统一般用的是小端存储，C/C++的存储与编译平台所在的CPU相关。





**小端存储** :便于数据之间的类型转换，例如:long类型转换为int类型时，高地址部分的数据可以直接截掉。起码正数是这样的，负数总不能把符号位截取了吧？

**大端存储** :便于数据类型的符号判断，因为最低地址位数据即为符号位，可以直接判断数据的正负号。



32位电脑表示内存寻址是32位，寄存器是32位，cpu是32位，操作系统是32位。32位 = 4字节，地址范围是 0 ~ 2^32  = 4G，所以32位操作系统的内存最大为4G。

64位操作系统同理，64位，地址范围 0 ~ 2^64 = 64G，所以64位操作系统最大内存位 64G？









常数

时间复杂度

HashMap(String, String)

HashMap(Integer, String)

HashMap(Node, String)

TreeMap()

注意头尾指向的修改，防止内存泄漏























